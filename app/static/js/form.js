"use strict";

/**
 * form.js - HADDOCK form generator
 */

/**
 * Coding style for this script:
 *
 * Write strict-mode compliant JavaScript. See:
 * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions_and_function_scope/Strict_mode#Changes_in_strict_mode
 *
 * Casing: camelCase  for variables and methods
 *         PascalCase for classes
 *         UPPER_CASE for constants
 *
 * Opening braces:       on the same line
 * Spaces around braces: only for inline functions: `function(){ a=1; }`
 *
 * Indentation: tabs
 * Alignment:   spaces (align assignments, string concats, etc.)
 *
 * Documentation: docblocks before every function
 *
 * Wrapping: recommended but not required, at column 120 or 80
 *           (assume a tab width of 4 characters)
 *
 * Aim for compatibility with Firefox 24+, Chrome 33+, Safari 5.1+ and IE8+.
 * Using jQuery where appropriate, there really shouldn't be any compatibility issues.
 */

/**
 * The execution order of this script is as follows:
 *
 * - Does a localStorage cache entry exist for the form HTML and is it up-to-date?
 *   - Yes:
 *     - Load form HTML into #haddockform > .content
 *   - No:
 *     - Use buildForm() to generate form HTML
 *       - Instantiate components (fill componentInstances, componentData) with instantiateComponents()
 *       - Render all component instances recursively (in parallel)
 *         - Render sections with makeSection()
 *           - Render parameters with makeParameter()
 *             - Render parameter values with makeValue()
 *       - Concatenate all generated instance HTML strings with flattenInstanceHTML()
 *     - Load form HTML into #haddockform > .content
 * - finalizeForm()
 *   - Attach event handlers to buttons, inputs, etc.
 *   - Set form level with setLevel() to a predefined value
 *   - Fold sections
 *   - Show the form
 *
 *
 * Further information on how form component objects are used by this script:
 *
 * XXX: This description might be a bit out of date @20140801
 *
 * `components[]` is a tree of components as generated by a CNS parser.
 * All components in this tree have a `type` property.
 * This type must be one of the following:
 * - `section`
 * - `parameter`
 * - `paragraph`
 *
 * Properties of components in this tree are attributes that define data types,
 * component repetition, default values, the required access levels, etc.
 *
 * Sections component objects contain a `children[]` array which can contain
 * child components of any type.
 *
 * On page load, the script goes through the components array and generates two
 * other component lists: `componentData[]` and `componentInstances[]`.
 *
 * `componentData[]` is basically a flat version of the `component[]` list. It is
 * used to provide quick access to a component's information using an index
 * number.
 *
 * `componentInstances[]` will be filled with instances of components.
 * Component instances contain a reference to a `components[]` object, and
 * depending on the component type:
 * - An optional reference to a parent instance
 * - An index in the componentInstances[] array
 * - An index in the component's own instances array
 * (for sections:)
 * - A list of child component instances in `children[]`
 * (for parameters:)
 * - A list of parameter values in `values[]`
 *
 * The original `components[]` objects get an `instances[]` array that points to
 * entries in the `componentInstances[]` array.
 *
 * For normal components, only one instance will be created. If a component is
 * of the section type and repeatable, the `repeat_min` (or `multi-min`, as it's
 * called in run.cns) attribute is used as the amount of instances to create
 * initially.
 * Repeatable parameters get their `values[]` array initialized with
 * `repeat_min` times the default value.
 *
 * After all initial component instances have been created, the rendering
 * process begins. Each component instance is rendered in parallel.
 * For section instances, start and end HTML strings are generated, to be
 * wrapped around child components. For non-section component instances, a
 * simple HTML string is generated.
 *
 * When all component instances are completely rendered, flattenComponentHTML()
 * loops through the `components[]` tree and concatenates the generated html for
 * each instance to create the form HTML.
 * We can't loop directly through `componentInstances[]` since it contains a
 * flat list of all instances, while we need to know the tree structure in this
 * step. Also, components with a `repeat_min` value of 0 do not start out with
 * any instances but must have a dummy form row.
 *
 * The HTML is then inserted into the form container (`#haddockform > .content`).
 * At this point, event handlers can be attached to the form.
 *
 * The initial HTML as generated above is also stored in localStorage, to allow
 * clients to skip the rendering step after the first time (but of course,
 * changes to the data model will be detected and will trigger a regeneration).
 */

$(function(){
	// Note that the members of components as provided by the webserver follow
	// a lowercase/underscore naming convention.
	var components         = formComponents;
	var componentData      = []; // Flat version of components[].
	var componentInstances = []; // Actual spawned sections and parameters, flat list
	var rootInstances      = []; // Component instances at the root level (for tree-structure looping)
	var renderables        = [];

	var componentCount         = 0;
	var componentInstanceCount = 0;
	var instancesRendered      = 0;

	var formHasChanged     = false;
	var formLevelTooHigh   = false;
	var formReady          = false;

	/**
	 * Change the form level.
	 *
	 * @param name the level name to switch
	 * @param force show/hide components even if we are already on the specified level
	 */
	function setLevel(name, force){
		if(
				$('.levelchooser li.selected')[0] === $('.levelchooser li.level-'+name)[0]
				&& force !== true
			){
			// We are already at the right level
			return;
		}

		if(!formLevelTooHigh && formLevels.indexOf(name) < formLevelIndex && formHasChanged && force !== true){
			// Because lower form levels hide certain fields, the user may lose
			// filled in data by switching to a lower form level.
			// Although we do not reset input fields, we should warn the user
			// that some parameters may not be saved.
			// Of course, we filter submitted fields based on access level on the server side as well.
			if(!confirm(
					'You may lose filled in parameters by switching to a lower form level.'
					+ "\nAre you sure you want to switch to the " + name + ' form?'
				)){
				return;
			}
		}

		formHasChanged = false;

		$('.levelchooser li.selected').removeClass('selected');
		$('.levelchooser li.level-'+name).addClass('selected');

		formLevelIndex = formLevels.indexOf(name);

		var rowsToHide = $('#haddockform .row:not([class~="level-' + name + '"])');
		var rowsToShow = $('#haddockform .row.level-' + name);

		if(Config.hideDisabledComponents){
			rowsToHide.hide();
			rowsToShow.show();
		}

		rowsToHide.find('> .value input, > .value select').prop('disabled', true);
		rowsToShow.find('> .value input, > .value select').prop('disabled', false);

		if(formLevelIndex > userLevel){
			formLevelTooHigh = true;

			$('.levelwarning').html(
				'<p>'
				+ ' <i class="fa fa-warning"></i>'
				+ ' Warning: Because your current access level is not high enough for the ' + name + ' interface,'
				+ ' you will be unable to submit this form.'
				+ ' Please <a href="mailto:/dev/null">request a higher access level</a> or choose a different form level above.'
				+ '</p>'
			);
			$('.levelwarning').slideDown(80);
			$('#haddockform input[type="submit"]').prop('disabled', true);
		}else{
			formLevelTooHigh = false;

			$('.levelwarning').slideUp(80);
			$('#haddockform input[type="submit"]').prop('disabled', false);
		}
	}

	/**
	 * Fold or unfold a section.
	 *
	 * @param section
	 * @param batch if true, do not attempt to animate folding
	 */
	function toggleSection(section, batch){
		var toggleButton = $(section).find('header > .togglebutton')[0];

		if($(section).hasClass('folded')){
			$(toggleButton).removeClass('fa-angle-double-up');
			$(toggleButton).addClass('fa-angle-double-down');
			$(section).removeClass('folded');
			if(batch === true)
				$($(section).find('.content')[0]).show();
			else
				$($(section).find('.content')[0]).slideDown(80);
		}else{
			$(toggleButton).removeClass('fa-angle-double-down');
			$(toggleButton).addClass('fa-angle-double-up');
			$(section).addClass('folded');
			if(batch === true)
				$($(section).find('.content')[0]).hide();
			else
				$($(section).find('.content')[0]).slideUp(80);
		}
	}

	/**
	 * Update the loading progressbar with a fraction.
	 *
	 * @param fraction a floating point number (0.0 - 1.0) indicating progress
	 */
	function setProgress(fraction){
		if(fraction > 1)
			fraction = 1;
		else if(fraction < 0)
			fraction = 0;

		var progressbar = $('#progressbar');
		progressbar.removeClass('indeterminate');
		progressbar.css('width', (fraction * 100) + '%');
	}

	/**
	 * Resets an input, select or checkbox group to its default value.
	 *
	 * @param input the element to reset
	 */
	function resetInput(input){
		var buttonSet = $('.buttonset[data-for="'+ $(input).attr('id') +'"]');
		//var row = $(input).parents('.row');
		//input.val(row.attr('data-default'));
		input.val(input.attr('data-default'));

		if(input.is('input[type="text"]')){
			input.val(input.attr('data-default'));
		}else if(input.is('select')){
			input.val(input.attr('data-default'));
		}else if(input.is('.checkgroup')){
			// Now let's just hope the default value doesn't contain double quotes...
			input.find('input[type="radio"][value="' + input.attr('data-default') + '"]').prop('checked', true);
		}

		$(buttonSet).find('i.reset').addClass('invisible');
	}

	// Multi- section/parameter code {{{

	/**
	 * Remove a section
	 *
	 * @param component the section's components / componentData entry
	 * @param repeatIndex
	 */
	function removeSection(component, repeatIndex){
		// TODO
	}

	/**
	 * Remove a parameter value
	 *
	 * @param component the parameter's components / componentData entry
	 * @param repeatIndex
	 */
	function removeParameterValue(component, repeatIndex){
		// TODO
	}

	/**
	 * Add a section (called when a plus button is pressed in a section header)
	 *
	 * @param container a "row" class div
	 * @param component the section's components / componentData entry
	 * @param repeatIndex
	 */
	function addSection(container, component, repeatIndex){
		// TODO: Create section
		// TODO: Attach event handlers
	}

	/**
	 * Add a parameter value (called when a plus button is pressed in a
	 * parameter row).
	 *
	 * @param container a "value" class div
	 * @param component the parameter's components / componentData entry
	 * @param repeatIndex
	 */
	function addParameterValue(container, component, repeatIndex){
		// TODO: Create parameter
		// TODO: Attach event handlers
	}

	// }}}
	// Event handlers {{{

	/**
	 * Event handler for reset buttons.
	 *
	 * @param e a click event
	 */
	function onResetButton(e){
		var buttonSet = $(this).parent('.buttonset');
		var input = $('#'+buttonSet.data('for'));
		resetInput(input);

		e.preventDefault();
		e.stopPropagation();
	}

	/**
	 * Event handler for minus buttons.
	 *
	 * @param e a click event
	 */
	function onMinusButton(e){
		var buttonSet = $(this).parent('.buttonset');
		removeParameterValue
		// Stop click events from reaching the header and folding this section
		e.preventDefault();
		e.stopPropagation();
	}

	/**
	 * Event handler for plus buttons.
	 *
	 * @param e a click event
	 */
	function onPlusButton(e){
		var buttonSet = $(this).parent('.buttonset');

		e.preventDefault();
		e.stopPropagation();
	}

	// }}}
	// HTML generators, templates {{{

	// NOTE: Using $('<el>') to create elements and el.attr() to assign
	//       attributes would be a lot more readable, but unfortunately this
	//       is a lot slower than generating HTML strings ourselves.

	/**
	 * Render repeat label and reset, add, remove buttons for a form component.
	 *
	 * @param component a section or parameter form component
	 * @param repeatIndex an optional index number for repeated components, -1 if this is a dummy section / value
	 *
	 * @return a buttonSet div
	 */
	function makeButtonSet(component, repeatIndex){
		if(typeof(repeatIndex) === 'undefined')
			repeatIndex = 0

		var buttonSet = '<div class="buttonset ' + component.type + '-buttons'
			+ (component.type === 'parameter' ? ' table-cell shrink' : ' float-right') + '"'
			+ ' data-for-data-index="' + component.dataIndex + '" data-for-instance="' + (component.repeat ? repeatIndex : '0') + '">';

		if(component.type === 'parameter'){
			buttonSet += '<i title="Reset to default value (' + component.default
				+ ')" class="reset fa fa-fw fa-undo invisible"></i>';
		}

		buttonSet += '<i title="Remove this ' + (component.type === 'section' ? 'block' : 'value') + '" '
			+ 'class="minus fa fa-fw fa-minus invisible"></i>';
		buttonSet += '<i title="Add a ' + (component.type === 'section' ? 'block' : 'value') + '" '
			+ 'class="plus fa fa-fw fa-plus'
			+ (!component.repeat || (component.repeat_max !== null && component.repeat_max <= repeatIndex) ? ' invisible' : '')
			+ '"></i>';

		buttonSet += '</div>';

		return buttonSet;
	}

	/**
	 * Create a section component.
	 *
	 * @param component the section component to build
	 * @param repeatIndex an optional index number for repeated sections, -1 to render a dummy section
	 *
	 * @return { start: <startHTML>, end: <endHTML> }
	 */
	function makeSectionHTML(component, repeatIndex){
		var sectionStart =
			  '<section' + (repeatIndex === -1 ? ' class="dummy"' : '') + '>'
			+ '<header>'
			+ '<i class="togglebutton fa fa-fw fa-lg fa-angle-double-down"></i>'
			+ '<span class="header-text">' + component.label + '</span>'
			+ makeButtonSet(component, repeatIndex)
			+ '</header>'
			+ '<div class="content">';

		var sectionEnd =
			  '</div>'
			+ '</section>';

		return { start: sectionStart, end: sectionEnd };
	}

	/**
	 * Make repeat_min amount of sections, or 1 if repeat is not set
	 *
	 * @param component
	 * @param callback
	 */
	function makeSection(component, callback){
		var repetitions = [];

		async.timesSeries(component.repeat ? component.repeat_min : 1, function(i, timesCallback){
			var repetition = {
				html: null,
				// Contents are other renderables
				content:  [],
				children: []
			};

			// XXX 1 or 0 based index?
			repetition.html = makeSectionHTML(component, i);

			repetitions.push(repetition);

			async.nextTick(timesCallback);
		}, function(){
			async.nextTick(function(){ callback(repetitions); });
		});
	}

	/**
	 * Create a value (input, select, checkbox group) for a parameter component.
	 *
	 * @param component the parameter component
	 * @param repeatIndex an optional index number for repeated parameters, -1 to render a dummy input
	 *
	 * @return a value element
	 */
	function makeValue(component, repeatIndex){
		var value = '<div class="value table"><div class="table-row">';

		var name = component.name;
		if(typeof(repeatIndex) !== 'undefined'){
			name += '_' + repeatIndex;
		}
		var id = 'f_' + name;

		if(repeatIndex === -1){
			var input = '<input type="text" class="table-cell dummy invisible" disabled />';
		}else if(component.datatype === 'choice' && component.options.length > 999){
			// Special case for radio buttons
			// TODO
			var input = '<div class="checkgroup table-cell" id="' + id + '" data-default="' + component.default + '">';

			// List all the options
			optLen = component.options.length;
			for(var i=0; i<optLen; i++){
				var checkbox = '<input type="radio" class="parameter" id="' + id + '_' + i + '" '
					+ 'name="' + name + '"' + (component.default === component.options[i] ? ' checked' : '')
					+ ' />';

				var label = '<label for="' + id + '_' + i + '">' + component.options[i] + '</label>';
				input += label;
			}
		}else{
			var idNameDefaultAttrs = 'id="' + id + '" name="' + name + '" ' + 'data-default="' + component.default + '"';

			if(component.datatype === 'choice'){
				var input = '<select class="parameter table-cell" '
					+ idNameDefaultAttrs + '>';
				// Select options
				for(var i=0; i<component.options.length; i++){
					input += '<option value="' + component.options[i] + '"'
						+ (component.default === component.options[i] ? ' selected' : '') + '>'
						+ component.options[i];
				}
				input += '</select>';
			}else if(component.datatype === 'string'){
				var input = '<input type="text" ' + idNameDefaultAttrs + ' value="' + component.default + '" />';
			}else if(component.datatype === 'integer'){
				var input = '<input type="text" pattern="\d*" ' + idNameDefaultAttrs + ' value="' + component.default + '" />';
			}else if(component.datatype === 'float'){
				var input = '<input type="text" pattern="\d*(\.\d+)?" ' + idNameDefaultAttrs + ' value="' + component.default + '" />';
			}else if(component.datatype === 'file'){
				var input = '<input type="file" ' + idNameDefaultAttrs + ' />';
			}else{
				alert('Error: Unknown datatype "' + component.datatype + '"');
				return;
			}
		}

		value += input;
		value += makeButtonSet(component);
		value += '</div></div>';

		return value;
	}

	/**
	 * Create a labeled parameter.
	 *
	 * @param component the parameter component to build
	 *
	 * @return an object containing a label and a value div
	 */
	function makeParameter(component){
		var label = '<label for="f_' + component.name + '" title="'
			+ '(' + component.datatype + ') ' + component.name + ' = ' + component.default + '">'
			+ (typeof(component.label) === 'undefined' ? component.name : component.label) + '</label>';

		if(component.repeat && component.repeat_min == 0){
			// Minimum amount of values is zero, do not render an input
			var value = makeValue(component, -1);
		}else{
			var value = makeValue(component);
		}

		return { 'label': label, 'value': value };
	}

	/**
	 * Create a documentation / standalone paragraph.
	 *
	 * @param component the paragraph component to build
	 *
	 * @return a paragraph element
	 */
	function makeParagraph(component){
		var paragraph = '<p class="documentation">' + component.text + '</p>';

		return paragraph;
	}

	/**
	 * Counts components.
	 * Fills componentData[].
	 * Adds instance arrays to components.
	 *
	 * @param components
	 * @param callback
	 */
	function prepareComponents(components, callback){
		async.each(components, function(component, componentCallback){
			if('hidden' in component && component.hidden){
				async.nextTick(componentCallback);
				return;
			}
			componentCount++;
			var dataIndex       = componentData.push(component) - 1;
			component.dataIndex = dataIndex;
			component.instances = [];
			async.nextTick(componentCallback);
		}, function(){
			async.nextTick(callback);
		});
	}

	/**
	 * Fills componentInstances[].
	 * Renders instances and dummies.
	 *
	 * @param components
	 * @param callback
	 */
	function renderComponents(components, callback, parentInstance, parentRepetition){
		var html = '';

		async.eachSeries(components, function(component, componentCallback){
			if('hidden' in component && component.hidden){
				async.nextTick(componentCallback);
				return;
			}
			html += '<div class="row';
			if('accesslevels' in component){
				var levelCount = component.accesslevels.length;
				for(var i=0; i<levelCount; i++)
					html += ' level-' + component.accesslevels[i];
			}

			html += '" data-data-index="' + component.dataIndex + '">';

			var isRootComponent = (typeof(parentInstance) === 'undefined' || parentInstance === null);

			var instance = {
				component:        component,
				parent:           parentInstance,
				parentRepetition: parentRepetition,
				hasDummy:         false
			};

			if(isRootComponent){
				rootInstances.push(instance);
			}else{
				parentInstance.repetitions[parentRepetition].children.push(instance);
			}

			if(component.type === 'section'){
				instance.repetitions = [];

				if(component.repeat && component.repeat_min == 0){
					instance.hasDummy  = true;
					var dummyHTML = makeSectionHTML(component, -1);
					instance.dummyHTML = dummyHTML.start + dummyHTML.end;

					html += instance.dummyHTML;
					async.nextTick(componentCallback);
				}else{
					makeSection(component, function(repetitions){
						instance.repetitions = repetitions;
						async.timesSeries(instance.repetitions.length, function(i, timesCallback){
							html += repetitions[i].html.start;
							renderComponents(component.children, function(repetitionHTML){
								html += repetitionHTML;
								html += repetitions[i].html.end;
								async.nextTick(timesCallback);
							}, instance, i);
						}, function(){
							html += '</div>';
							async.nextTick(componentCallback);
						});
					});
				}
			}else{
				if(component.type === 'parameter'){
					var parameter = makeParameter(component);
					html += parameter.label + parameter.value;
				}else if(component.type === 'paragraph'){
					html += makeParagraph(component);
				}else{
					alert('Error: Can\'t render unknown component type: ' + component.type);
				}

				html += '</div>';
				async.nextTick(componentCallback);
			}
		}, function(){
			async.nextTick(function(){ callback(html); });
		});
	}

	// }}}

	/**
	 * Attach event handlers.
	 * Basically, adds everything to the form that can't be saved in a cache.
	 *
	 * @param c_callback called on completion
	 */
	function finalizeForm(c_callback){
		async.series([
			function(callback){
				// Attach all event handlers here
				// TODO: Put event handlers in separate functions

				// TODO: Perhaps it is better to use delegated events
				//       instead of adding event handlers every time a section
				//       or parameter is multiplied.

				$('#haddockform header').click(function(e){
					toggleSection($(this).parent('section'));
				});

				$('#haddockform input[type="text"]').focus(function(e){
					// Automatically select input element contents on focus
					$(this).one('mouseup', function(){
						$(this).select();
						return false;
					})
					$(this).select();
				});

				$('#haddockform input, #haddockform select').change(function(e){
					formHasChanged = true;

					if($(this).is('input[type="text"]') || $(this).is('select')){
						var buttonSet = $('.buttonset[data-for="'+ $(this).attr('id') +'"]');
						if($(this).val() == $(this).attr('data-default')){
							buttonSet.find('.reset').addClass('invisible');
						}else{
							buttonSet.find('.reset').removeClass('invisible');
						}
					}else if($(this).is('.buttongroup')){
						//buttonSet.find('.reset').removeClass('invisible');
					}
				});

				$('#haddockform .buttonset i.reset').click(onResetButton);

				async.nextTick(callback);
			},
			function(callback){
				// Fold all sections
				//$('#haddockform section').each(function(){ toggleSection(this, true); });
				// Set form level
				setLevel(formLevel, true);
				// Show the form
				$('.loading').addClass('hidden');
				$('#haddockform').removeClass('hidden');
				formReady = true;
				async.nextTick(callback);
			}
		], c_callback);
	}

	/**
	 * Build a form with the specified list of components.
	 *
	 * @param components
	 * @param c_callback called on completion
	 */
	function buildForm(components, callback){
		// We're not hanging your browser, don't worry
		$('html').css('cursor', 'progress');

		var html;

		async.series([
			function(stepCallback){
				prepareComponents(components, function(){
					$('#components-total').html(componentCount);
					async.nextTick(stepCallback);
				});
			},
			function(stepCallback){
				setProgress(0);
				$('#progress-activity').html('Building form');
				$('#component-progress, .progress-container').removeClass('hidden');
				renderComponents(components, function(renderedHTML){
					html = renderedHTML;
					async.nextTick(stepCallback);
				});
			},
			function(stepCallback){
				$('#progress-activity').html('Rendering');
				var progressbar = $('#progressbar');
				progressbar.css('width', '');
				progressbar.addClass('indeterminate');
				$('#component-progress').addClass('hidden');
				async.nextTick(stepCallback);
			},
		], function(err){
			$('html').css('cursor', '');
			async.nextTick(function(){ callback(html); });
		});
	}

	function storeForm(html){
		simpleStorage.deleteKey('haddock_form_version');
		simpleStorage.deleteKey('haddock_form');

		console.log('storing form version: ' + modelVersionTag);
		simpleStorage.set('haddock_form_version', modelVersionTag);
		simpleStorage.set('haddock_form', html);
	}

	/**
	 * Load the HADDOCK form.
	 *
	 * This will load the HTML for the form either by using the localStorage
	 * cache or by generating it on page load using buildForm().
	 *
	 * @param forceRenew when true, no attempt is made to load the form from cache
	 */
	function loadForm(forceRenew){
		var storedVersion = simpleStorage.get('haddock_form_version');
		if(typeof(forceRenew) !== 'undefined' && forceRenew){
			console.log('force-refreshing form, dropping html cache');
		}else if(storedVersion === modelVersionTag){
			console.log('stored form html version ' + storedVersion + ' is up to date');
			var form = simpleStorage.get('haddock_form');
		}else if(typeof(storedVersion) !== 'undefined'
				&& storedVersion !== null
				&& storedVersion !== false
				&& storedVersion.length){
			// If only there were a cross-browser method of checking whether a localStorage key exists
			console.log('stored form html version ' + storedVersion + ' is out of date, generating new version '
				+ modelVersionTag);
		}else{
			console.log('no valid form cache found, generating new form version ' + modelVersionTag);
		}

		if(typeof(form) === 'undefined' || form === null || form === false || !form.length){
			async.waterfall([
				function(callback){
					buildForm(formComponents, function(result){ callback(null, result); });
				},
				function(result, callback){
					// Note: [0].innerHTML should be faster than html() but the
					//       difference is barely noticable in FF, Chrome and Safari.
					//       Also, cross-browser compatibility would not be guaranteed.
					$('#haddockform > .content').html(result);
					storeForm(result);
					finalizeForm();
				}
			]);
		}else{
			$('#haddockform > .content').html(form);
			finalizeForm();
		}
	}

	$('.levelchooser li').click(function(e){
		// TODO: Enable after form loading
		setLevel($(this).data('name'));
	});

	async.nextTick(function(){
		// Don't load from localStorage cache if the query string contains "nocache".
		// Doing an indexOf on the entire query string is a bit hacky,
		// but we do not have any other parameters, so it's OK for now.
		if(window.location.search.indexOf('nocache') === -1)
			loadForm();
		else
			loadForm(true);
	});
});
